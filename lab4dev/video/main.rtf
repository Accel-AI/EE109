{\rtf1\ansi\deff0{\fonttbl{\f0\fmodern\fprq1\fcharset0;}}{\colortbl;\red136\green136\blue136;\red186\green33\blue33;\red0\green68\blue221;\red102\green102\blue102;\red64\green128\blue128;\red160\green160\blue0;\red25\green23\blue124;\red0\green128\blue0;\red187\green102\blue136;\red187\green102\blue34;\red136\green0\blue0;\red170\green34\blue255;\red153\green153\blue153;\red0\green160\blue0;\red160\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red176\green0\blue64;\red0\green0\blue255;\red187\green187\blue187;\red188\green122\blue0;\red0\green0\blue128;\red125\green144\blue41;\red210\green65\blue58;}\f0{\cf5\i // Some key code snipptes have been borrowed from the designs published at the rocketboard.org:\par
}{\cf5\i // https://rocketboards.org/foswiki/Projects/VideoAndImageProcessingWithArria10SoCDevkit\par
}\par
{\cf21 #}{\cf21 ifdef __cplusplus}{\cf21 \par
}{\cf8\b extern} {\cf2 "}{\cf2 C}{\cf2 "} \{\par
{\cf21 #}{\cf21 endif}{\cf21 \par
}\par
{\cf21 #}{\cf21 include <errno.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <sys}{\cf21 /}{\cf21 types.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <sys}{\cf21 /}{\cf21 stat.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <fcntl.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <sys}{\cf21 /}{\cf21 ioctl.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <unistd.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <stdint.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <stdio.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <stdlib.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <asm}{\cf21 /}{\cf21 types.h>}{\cf21 \par
}\par
{\cf21 #}{\cf21 include <linux}{\cf21 /}{\cf21 videodev2.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <sys}{\cf21 /}{\cf21 mman.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <string.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <malloc.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <linux}{\cf21 /}{\cf21 fb.h>}{\cf21 \par
}\par
{\cf21 #}{\cf21 include <netdb.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <string.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <sys}{\cf21 /}{\cf21 socket.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <netinet}{\cf21 /}{\cf21 in.h>}{\cf21 \par
}{\cf21 #}{\cf21 include <arpa}{\cf21 /}{\cf21 inet.h>}{\cf21 \par
}\par
{\cf21 #}{\cf21 define BUFLEN 2048}{\cf21 \par
}{\cf21 #}{\cf21 define SERVICE_PORT 21234}{\cf21 \par
}\par
{\cf21 #}{\cf21 define TEST_BUFFER_NUM 8}{\cf21 \par
}{\cf21 #}{\cf21 define SAT(c) \\}{\cf21 \par
}{\cf21    if (c & (~255)) \{ if (c < 0) c = 0; else c = 255; \}}{\cf21 \par
}\par
{\cf8\b struct} testbuffer\par
\{\par
    {\cf18 unsigned} {\cf18 char} {\cf4 *}start;\par
    {\cf18 size_t} offset;\par
    {\cf18 unsigned} {\cf18 int} length;\par
\};\par
\par
{\cf8\b struct} testbuffer buffers[TEST_BUFFER_NUM];\par
{\cf18 int} g_in_width {\cf4 =} {\cf4 1280};\par
{\cf18 int} g_in_height {\cf4 =} {\cf4 720};\par
{\cf18 int} g_out_width {\cf4 =} {\cf4 1280};\par
{\cf18 int} g_out_height {\cf4 =} {\cf4 720};\par
{\cf18 int} g_top {\cf4 =} {\cf4 0};\par
{\cf18 int} g_left {\cf4 =} {\cf4 0};\par
{\cf18 int} g_input {\cf4 =} {\cf4 0};\par
{\cf18 int} g_capture_count {\cf4 =} {\cf4 100};\par
{\cf18 int} g_rotate {\cf4 =} {\cf4 0};\par
{\cf18 int} g_cap_fmt {\cf4 =} V4L2_PIX_FMT_YUYV;\par
{\cf18 int} g_camera_framerate {\cf4 =} {\cf4 30};\par
{\cf18 int} g_extra_pixel {\cf4 =} {\cf4 0};\par
{\cf18 int} g_capture_mode {\cf4 =} {\cf4 0};\par
{\cf18 char} g_v4l_device[{\cf4 100}] {\cf4 =} {\cf2 "}{\cf2 /dev/video0}{\cf2 "};\par
{\cf18 char} g_fb_device[{\cf4 100}] {\cf4 =} {\cf2 "}{\cf2 /dev/fb0}{\cf2 "};\par
{\cf18 char} g_file_name[{\cf4 100}] {\cf4 =} {\cf2 "}{\cf2 Capture.jpg}{\cf2 "};\par
\par
{\cf5\i /* Global Variables */}\par
{\cf8\b static} {\cf18 char} cmd[{\cf4 512}];\par
\par
{\cf8\b static} {\cf18 void} {\cf19 yuyv_to_rgb32} ({\cf18 int} width, {\cf18 int} height, {\cf18 char} {\cf4 *}src, {\cf18 long} {\cf4 *}dst)\par
\{\par
    {\cf5\i // TODO: Your job to do the color space conversion\par
}    {\cf5\i // TODO: How to calculate the adjacent one?\par
}    {\cf18 unsigned} {\cf18 char} {\cf4 *}s;\par
    {\cf18 unsigned} {\cf18 long} {\cf4 *}d;\par
    {\cf18 int} l, c, alpha {\cf4 =} {\cf4 0x0};\par
    {\cf18 int} r, g, b, cr, cg, cb, y1, y2;\par
\par
    l {\cf4 =} height;\par
    s {\cf4 =} src;\par
    d {\cf4 =} dst;\par
    {\cf8\b while} (l{\cf4 -}{\cf4 -}) \{\par
        c {\cf4 =} width {\cf4 >}{\cf4 >} {\cf4 1};\par
        {\cf8\b while} (c{\cf4 -}{\cf4 -}) \{\par
            y1 {\cf4 =} {\cf4 *}s{\cf4 +}{\cf4 +};\par
            cb {\cf4 =} (({\cf4 *}s {\cf4 -} {\cf4 128}) {\cf4 *} {\cf4 454}) {\cf4 >}{\cf4 >} {\cf4 8};\par
            cg {\cf4 =} ({\cf4 *}s{\cf4 +}{\cf4 +} {\cf4 -} {\cf4 128}) {\cf4 *} {\cf4 88};\par
            y2 {\cf4 =} {\cf4 *}s{\cf4 +}{\cf4 +};\par
            cr {\cf4 =} (({\cf4 *}s {\cf4 -} {\cf4 128}) {\cf4 *} {\cf4 359}) {\cf4 >}{\cf4 >} {\cf4 8};\par
            cg {\cf4 =} (cg {\cf4 +} ({\cf4 *}s{\cf4 +}{\cf4 +} {\cf4 -} {\cf4 128}) {\cf4 *} {\cf4 183}) {\cf4 >}{\cf4 >} {\cf4 8};\par
\par
            r {\cf4 =} y1 {\cf4 +} cr;\par
            b {\cf4 =} y1 {\cf4 +} cb;\par
            g {\cf4 =} y1 {\cf4 -} cg;\par
            SAT(r);\par
            SAT(g);\par
            SAT(b);\par
            {\cf4 *}dst{\cf4 +}{\cf4 +} {\cf4 =} (({\cf18 unsigned} {\cf18 int}) alpha) {\cf4 <}{\cf4 <} {\cf4 24} {\cf4 |}  (r {\cf4 <}{\cf4 <} {\cf4 16}) {\cf4 |} (g {\cf4 <}{\cf4 <} {\cf4 8}) {\cf4 |} b;\par
\par
            r {\cf4 =} y2 {\cf4 +} cr;\par
            b {\cf4 =} y2 {\cf4 +} cb;\par
            g {\cf4 =} y2 {\cf4 -} cg;\par
            SAT(r);\par
            SAT(g);\par
            SAT(b);\par
            {\cf4 *}dst{\cf4 +}{\cf4 +} {\cf4 =} (({\cf18 unsigned} {\cf18 int}) alpha) {\cf4 <}{\cf4 <} {\cf4 24} {\cf4 |}  (r {\cf4 <}{\cf4 <} {\cf4 16}) {\cf4 |} (g {\cf4 <}{\cf4 <} {\cf4 8}) {\cf4 |} b;\par
        \}\par
    \}\par
\}\par
\par
{\cf8\b static} {\cf18 int} {\cf19 start_capturing}({\cf18 int} fd_v4l)\par
\{\par
    {\cf18 unsigned} {\cf18 int} i;\par
    {\cf8\b struct} v4l2_buffer buf;\par
    {\cf8\b enum} v4l2_buf_type type;\par
\par
    {\cf8\b for} (i {\cf4 =} {\cf4 0}; i {\cf4 <} TEST_BUFFER_NUM; i{\cf4 +}{\cf4 +})\par
    \{\par
        memset({\cf4 &}buf, {\cf4 0}, {\cf8\b sizeof} (buf));\par
        buf.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
        buf.memory {\cf4 =} V4L2_MEMORY_MMAP;\par
        buf.index {\cf4 =} i;\par
        {\cf8\b if} (ioctl(fd_v4l, VIDIOC_QUERYBUF, {\cf4 &}buf) {\cf4 <} {\cf4 0})\par
        \{\par
            printf({\cf2 "}{\cf2 VIDIOC_QUERYBUF error}{\cf10\b \\n}{\cf2 "});\par
            {\cf8\b return} {\cf4 -}{\cf4 1};\par
        \}\par
\par
        buffers[i].length {\cf4 =} buf.length;\par
        buffers[i].offset {\cf4 =} ({\cf18 size_t}) buf.m.offset;\par
        buffers[i].start {\cf4 =} mmap ({\cf8 NULL}, buffers[i].length,\par
                                 PROT_READ {\cf4 |} PROT_WRITE, MAP_SHARED,\par
                                 fd_v4l, buffers[i].offset);\par
        memset(buffers[i].start, {\cf4 0xFF}, buffers[i].length);\par
    \}\par
\par
    {\cf8\b for} (i {\cf4 =} {\cf4 0}; i {\cf4 <} TEST_BUFFER_NUM; i{\cf4 +}{\cf4 +})\par
    \{\par
        memset({\cf4 &}buf, {\cf4 0}, {\cf8\b sizeof} (buf));\par
        buf.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
        buf.memory {\cf4 =} V4L2_MEMORY_MMAP;\par
        buf.index {\cf4 =} i;\par
        buf.m.offset {\cf4 =} buffers[i].offset;\par
\par
        {\cf8\b if} (ioctl (fd_v4l, VIDIOC_QBUF, {\cf4 &}buf) {\cf4 <} {\cf4 0}) \{\par
            printf({\cf2 "}{\cf2 VIDIOC_QBUF error}{\cf10\b \\n}{\cf2 "});\par
            {\cf8\b return} {\cf4 -}{\cf4 1};\par
        \}\par
    \}\par
\par
    type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
    {\cf8\b if} (ioctl (fd_v4l, VIDIOC_STREAMON, {\cf4 &}type) {\cf4 <} {\cf4 0}) \{\par
        printf({\cf2 "}{\cf2 VIDIOC_STREAMON error}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 -}{\cf4 1};\par
    \}\par
    {\cf8\b return} {\cf4 0};\par
\}\par
\par
{\cf8\b static} {\cf18 int} {\cf19 stop_capturing}({\cf18 int} fd_v4l)\par
\{\par
    {\cf8\b enum} v4l2_buf_type type;\par
    {\cf18 unsigned} {\cf18 int} i;\par
\par
    type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
    ioctl (fd_v4l, VIDIOC_STREAMOFF, {\cf4 &}type);\par
\par
    {\cf8\b for} (i {\cf4 =} {\cf4 0}; i {\cf4 <} TEST_BUFFER_NUM; i{\cf4 +}{\cf4 +})\par
    \{\par
        munmap(buffers[i].start, buffers[i].length);\par
    \}\par
    {\cf8\b return} {\cf4 0};\par
\}\par
\par
{\cf8\b static} {\cf18 int} {\cf19 v4l_capture_setup}({\cf18 void})\par
\{\par
    {\cf8\b struct} v4l2_format fmt;\par
    {\cf8\b struct} v4l2_control ctrl;\par
    {\cf8\b struct} v4l2_streamparm parm;\par
    {\cf8\b struct} v4l2_crop crop;\par
    {\cf18 int} fd_v4l {\cf4 =} {\cf4 0};\par
\par
    {\cf8\b if} ((fd_v4l {\cf4 =} open(g_v4l_device, O_RDWR, {\cf4 0})) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 Unable to open %s}{\cf10\b \\n}{\cf2 "}, g_v4l_device);\par
        {\cf8\b return} {\cf4 0};\par
    \}\par
\par
    fmt.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
    fmt.fmt.pix.pixelformat {\cf4 =} g_cap_fmt;\par
    fmt.fmt.pix.width {\cf4 =} g_out_width;\par
    fmt.fmt.pix.height {\cf4 =} g_out_height;\par
    {\cf8\b if} (ioctl(fd_v4l, VIDIOC_S_FMT, {\cf4 &}fmt) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 set format failed}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 0};\par
    \}\par
\par
\par
    {\cf8\b struct} v4l2_requestbuffers req;\par
    memset({\cf4 &}req, {\cf4 0}, {\cf8\b sizeof} (req));\par
    req.count {\cf4 =} TEST_BUFFER_NUM;\par
    req.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
    req.memory {\cf4 =} V4L2_MEMORY_MMAP;\par
\par
    {\cf8\b if} (ioctl(fd_v4l, VIDIOC_REQBUFS, {\cf4 &}req) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 v4l_capture_setup: VIDIOC_REQBUFS failed}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 0};\par
    \}\par
\par
    {\cf8\b return} fd_v4l;\par
\}\par
\par
\par
{\cf8\b static} {\cf18 int} {\cf19 v4l_stream_test}({\cf18 int} fd_v4l)\par
\{\par
    {\cf5\i // TODO: Add networking component here\par
}    {\cf8\b struct} sockaddr_in myaddr, remaddr;\par
    {\cf18 int} fd, inet, slen{\cf4 =}{\cf8\b sizeof}(remaddr);\par
    {\cf18 char} messagebuf[BUFLEN];\par
    {\cf18 int} recvlen;\par
    {\cf18 char} {\cf4 *}server {\cf4 =} {\cf2 "}{\cf2 172.24.72.54}{\cf2 "};\par
\par
    {\cf8\b if} ((fd{\cf4 =}socket(AF_INET, SOCK_DGRAM, {\cf4 0})) {\cf4 =}{\cf4 =} {\cf4 -}{\cf4 1})\par
        {\cf8\b return} {\cf4 0};\par
\par
    {\cf5\i // Set up the network infra\par
}    memset(({\cf18 char} {\cf4 *}) {\cf4 &}myaddr, {\cf4 0}, {\cf8\b sizeof}(myaddr));\par
    myaddr.sin_family {\cf4 =} AF_INET;\par
    myaddr.sin_addr.s_addr {\cf4 =} htonl(INADDR_ANY);\par
    myaddr.sin_port {\cf4 =} htons({\cf4 0});\par
\par
    {\cf8\b if} (bind(fd, ({\cf8\b struct} sockaddr {\cf4 *}){\cf4 &}myaddr, {\cf8\b sizeof}(myaddr)) {\cf4 <} {\cf4 0})\par
    \{\par
        perror({\cf2 "}{\cf2 bind failed}{\cf2 "});\par
        {\cf8\b return} {\cf4 0};\par
    \}\par
\par
    memset(({\cf18 char} {\cf4 *}) {\cf4 &}remaddr, {\cf4 0}, {\cf8\b sizeof}(remaddr));\par
    remaddr.sin_family {\cf4 =} AF_INET;\par
    remaddr.sin_port {\cf4 =} htons(SERVICE_PORT);\par
    {\cf8\b if} (inet_aton(server, {\cf4 &}remaddr.sin_addr) {\cf4 =}{\cf4 =} {\cf4 0})\par
    \{\par
        fprintf(stderr, {\cf2 "}{\cf2 inet_aton() failed}{\cf10\b \\n}{\cf2 "});\par
        exit({\cf4 1});\par
    \}\par
\par
    {\cf8\b struct} v4l2_buffer buf;\par
    {\cf8\b struct} v4l2_format fmt;\par
    {\cf8\b struct} fb_var_screeninfo vinfo;\par
    {\cf8\b struct} fb_fix_screeninfo finfo;\par
    {\cf18 long} screensize, index;\par
    {\cf18 int} fbfd {\cf4 =} {\cf4 0};\par
    {\cf18 char} {\cf4 *}fbp;\par
    {\cf18 unsigned} {\cf18 char} Bmp, dummy, red, blue, green, alpha;\par
    {\cf18 long} {\cf4 *}bgr_buff;\par
    {\cf18 FILE} {\cf4 *} fd_y_file {\cf4 =} {\cf4 0};\par
    {\cf18 int} i,hindex,j;\par
    {\cf18 unsigned} {\cf18 long} {\cf18 int} location {\cf4 =} {\cf4 0}, BytesPerLine {\cf4 =} {\cf4 0};\par
    {\cf18 unsigned} {\cf18 long} pixel;\par
    {\cf18 unsigned} {\cf18 int} t,x,y;\par
    {\cf18 unsigned} {\cf18 long} size, bytes_read;\par
\par
    {\cf8\b if} ((fbfd {\cf4 =} open(g_fb_device, O_RDWR, {\cf4 0})) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 Unable to open %s}{\cf10\b \\n}{\cf2 "}, g_v4l_device);\par
        {\cf8\b return} {\cf4 0};\par
    \}\par
\par
    {\cf5\i /* Get fixed screen information */}\par
    {\cf8\b if} (ioctl(fbfd, FBIOGET_FSCREENINFO, {\cf4 &}finfo)) \{\par
        printf({\cf2 "}{\cf2 Error reading fixed information.}{\cf10\b \\n}{\cf2 "});\par
        exit({\cf4 2});\par
    \}\par
\par
    {\cf5\i /* Get variable screen information */}\par
    {\cf8\b if} (ioctl(fbfd, FBIOGET_VSCREENINFO, {\cf4 &}vinfo)) \{\par
        printf({\cf2 "}{\cf2 Error reading variable information.}{\cf10\b \\n}{\cf2 "});\par
        exit({\cf4 3});\par
    \}\par
\par
    {\cf5\i /* Figure out the size of the screen in bytes */}\par
    screensize {\cf4 =} vinfo.xres {\cf4 *} vinfo.yres {\cf4 *} vinfo.bits_per_pixel {\cf4 /} {\cf4 8};\par
\par
    {\cf5\i /* Map the device to memory */}\par
    fbp {\cf4 =} ({\cf18 char} {\cf4 *})mmap({\cf4 0}, screensize, PROT_READ {\cf4 |} PROT_WRITE, MAP_SHARED,fbfd, {\cf4 0});\par
    {\cf8\b if} (({\cf18 int})fbp {\cf4 =}{\cf4 =} {\cf4 -}{\cf4 1}) \{\par
        printf({\cf2 "}{\cf2 Error failed to map framebuffer device to memory.}{\cf10\b \\n}{\cf2 "});\par
        exit({\cf4 4});\par
    \}\par
\par
    fmt.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
    {\cf8\b if} (ioctl(fd_v4l, VIDIOC_G_FMT, {\cf4 &}fmt) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 get format failed}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 -}{\cf4 1};\par
    \}\par
\par
    {\cf8\b if} (start_capturing(fd_v4l) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 start_capturing failed}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 -}{\cf4 1};\par
    \}\par
\par
    bgr_buff {\cf4 =} ({\cf18 long} {\cf4 *}) malloc ({\cf8\b sizeof}({\cf18 long}) {\cf4 *} fmt.fmt.pix.width {\cf4 *} fmt.fmt.pix.height {\cf4 *} {\cf4 4});\par
\par
    {\cf8\b for}(;;) \{\par
        memset({\cf4 &}buf, {\cf4 0}, {\cf8\b sizeof} (buf));\par
        buf.type {\cf4 =} V4L2_BUF_TYPE_VIDEO_CAPTURE;\par
        buf.memory {\cf4 =} V4L2_MEMORY_MMAP;\par
        {\cf8\b if} (ioctl (fd_v4l, VIDIOC_DQBUF, {\cf4 &}buf) {\cf4 <} {\cf4 0})	\{\par
            printf({\cf2 "}{\cf2 VIDIOC_DQBUF failed.}{\cf10\b \\n}{\cf2 "});\par
            {\cf8\b break};\par
        \}\par
\par
        yuyv_to_rgb32(g_out_width, g_out_height, buffers[buf.index].start, bgr_buff);\par
        memcpy(fbp, bgr_buff, (vinfo.xres {\cf4 *} vinfo.yres {\cf4 *} vinfo.bits_per_pixel){\cf4 /}{\cf4 8});\par
\par
        {\cf8\b if} (ioctl (fd_v4l, VIDIOC_QBUF, {\cf4 &}buf) {\cf4 <} {\cf4 0}) \{\par
            printf({\cf2 "}{\cf2 VIDIOC_QBUF failed}{\cf10\b \\n}{\cf2 "});\par
            {\cf8\b break};\par
        \}\par
    \}\par
\par
    {\cf8\b if} (stop_capturing(fd_v4l) {\cf4 <} {\cf4 0})\par
    \{\par
        printf({\cf2 "}{\cf2 stop_capturing failed}{\cf10\b \\n}{\cf2 "});\par
        {\cf8\b return} {\cf4 -}{\cf4 1};\par
    \}\par
\par
    free(bgr_buff);\par
    munmap(fbp, screensize);\par
    close(fbfd);\par
    close(fd_v4l);\par
    {\cf8\b return} {\cf4 0};\par
\}\par
\par
\par
\par
{\cf18 int} {\cf19 main}({\cf18 int} argc, {\cf18 char} {\cf4 *}{\cf4 *}argv)\par
\{\par
\par
  {\cf18 int} fp {\cf4 =} {\cf4 0};\par
  {\cf18 char} brightness_char[{\cf4 100}] {\cf4 =} {\cf2 "}{\cf2 /sys/class/leds/a10sycon_led0/brightness}{\cf2 "};\par
  {\cf8\b if} ((fp {\cf4 =} open(brightness_char, O_RDWR, {\cf4 0})) {\cf4 <} {\cf4 0})\par
  \{\par
    printf({\cf2 "}{\cf2 Failed to change the brightness}{\cf2 "});\par
  \}\par
  {\cf8\b else}\par
  \{\par
    write(fp, {\cf2 "}{\cf2 1}{\cf2 "}, {\cf8\b sizeof}(brightness_char));\par
    close(fp);\par
  \}\par
\par
    {\cf8\b return} {\cf4 0};\par
\par
    {\cf18 int} fd_v4l, option {\cf4 =} {\cf4 0}, img_sel {\cf4 =} {\cf4 0};\par
\par
    fd_v4l {\cf4 =} v4l_capture_setup();\par
    v4l_stream_test(fd_v4l);\par
    {\cf8\b return} {\cf4 0};\par
\}\par
}